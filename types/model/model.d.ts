import { Agent } from "./agent";
import { ReferGroup } from "../types/refer";
import { Chunk, ChildChunk } from "../types/chunk";
import { DecorReceiver, DecorReceivers, DecorUpdater } from "../types/decor";
import { BaseEvent, EventEmitters, EventHandler, EventProducers } from "../types/event";
import { Props, StrictProps } from "../types/props";
import { Value } from "../types";
import { EventProducer } from "@/submodel/event";
type BaseModel = Model<string, {}, {}, {}, BaseModel | undefined, {}, BaseModel, {}, {}>;
export declare namespace Model {
    type Props<M extends Model> = M['props'];
    type Chunk<M extends Model> = M['chunk'];
    type Agent<M extends Model> = M['agent'];
    type State<M extends Model> = M['state'];
    type Child<M extends Model> = M['child'];
    type Refer<M extends Model> = M['refer'];
}
export declare abstract class Model<I extends string = string, E extends Record<string, any> = {}, S1 extends Record<string, Value> = {}, S2 extends Record<string, Value> = {}, P extends Model | undefined = BaseModel | undefined, C1 extends Record<string, Model> = {}, C2 extends Model = BaseModel, R1 extends Record<string, Model> = {}, R2 extends Record<string, Model> = {}> {
    get state(): Readonly<S1 & S2>;
    private stateDecorated;
    private stateSnapshot?;
    private stateReleased;
    private readonly stateWorkspace;
    protected readonly stateDelegator: S1 & S2;
    private stateChecklist;
    private copyChild;
    get child(): Readonly<C1 & C2[]>;
    private childReleased;
    private childSnapshot?;
    private readonly childWorkspace;
    protected readonly childDelegator: ChildChunk<C1, C2>;
    readonly event: Readonly<EventProducers<E & BaseEvent<this>, this>>;
    readonly eventEmitters: Readonly<EventEmitters<E>>;
    private readonly eventConsumers;
    private readonly eventProducers;
    readonly decor: Readonly<DecorReceivers<S1, this>>;
    private readonly decorProviders;
    private readonly decorReceivers;
    readonly path: string;
    readonly uuid: string;
    readonly code: I;
    readonly root: Model;
    readonly parent: P;
    readonly target: this;
    private copyRefer;
    get refer(): Readonly<ReferGroup<R1, R2>>;
    private referReleased;
    private referSnapshot?;
    private readonly referWorkspace;
    protected readonly referDelegator: ReferGroup<R1, R2>;
    readonly agent: Agent<E, S1, C1, C2, this>;
    get props(): Readonly<Props<I, S1, S2, P, C1, C2, R1, R2>>;
    get chunk(): Readonly<Chunk<I, S1, S2, C1, C2, R1, R2>>;
    constructor(props: StrictProps<I, S1, S2, P, C1, C2, R1, R2>);
    private static root;
    static createRoot<M extends Model>(props: Model.Chunk<M>): M | undefined;
    private getState;
    private setRefer;
    private deleteRefer;
    private getRefer;
    private getChild;
    private pushChild;
    private popChild;
    private unshiftChild;
    private fillChild;
    private shiftChild;
    private setChild;
    private deleteChild;
    private spliceChild;
    private createChild;
    private deleteState;
    private setState;
    setStateBatch(updater: (prev: S1 & S2) => Partial<S1 & S2>): void;
    addChild(): void;
    removeChild(): void;
    swapChild(): void;
    resetState(path: string): void;
    commitState(): void;
    commitChild(): void;
    commitRefer(): void;
    clear(): void;
    private getDecor;
    private getEvent;
    private getEventEmitter;
    private emitDecor;
    private emitEvent;
    protected bindEvent<E, M extends Model>(producer: EventProducer<E, M>, handler: EventHandler<E, M>): void;
    protected unbindEvent<E, M extends Model>(producer: EventProducer<E, M>, handler: EventHandler<E, M>): void;
    protected bindDecor<S, M extends Model>(receiver: DecorReceiver<S, M>, updater: DecorUpdater<S, M>): void;
    debug(): void;
    protected unbindDecor<S, M extends Model>(receiver: DecorReceiver<S, M>, updater: DecorUpdater<S, M>): void;
    private isInited;
    private load;
    private unload;
    private static hooksEvent;
    protected static useEvent<E, M extends Model>(accessor: (model: M) => EventProducer<E, M> | undefined): (target: M, key: string, descriptor: TypedPropertyDescriptor<EventHandler<E, M>>) => TypedPropertyDescriptor<EventHandler<E, M>>;
    private static hooksDecor;
    protected static useDecor<S, M extends Model, T extends Model>(accessor: (model: T) => DecorReceiver<S, M> | undefined): (target: T, key: string, descriptor: TypedPropertyDescriptor<DecorUpdater<S, M>>) => TypedPropertyDescriptor<DecorUpdater<S, M>>;
}
export {};
